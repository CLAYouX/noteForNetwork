[TOC]

## 一、基础篇

### 1.1 TCP/IP 网络模型

对于同⼀台设备上的进程间通信，有很多种⽅式，⽐如有管道、消息队列、共享内存、信号等⽅式，⽽对于不同设
备上的进程间通信，就需要⽹络通信，⽽设备是多样性的，所以要兼容多种多样的设备，就协商出了⼀套 **通⽤的⽹络协议**。

这个⽹络协议是分层的，每⼀层都有各⾃的作⽤和职责。

#### 应用层

应⽤层只需要专注于为⽤户提供应⽤功能，不⽤去关⼼数据是如何传输的。

应⽤层是⼯作在操作系统中的 **⽤户态**，传输层及以下则⼯作在内核态。

#### 传输层

应⽤层的数据包会传给传输层，**传输层（Transport Layer）** 是为应⽤层提供⽹络⽀持的。

在传输层会有两个传输协议，分别是 **TCP** 和 **UDP**。

应⽤需要传输的数据可能会⾮常⼤，如果直接传输就不好控制，因此当传输层的数据包⼤⼩超过 **MSS（TCP 最⼤报⽂段⻓度）** ，就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重新这⼀个分块，⽽不⽤重新发送整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 **TCP 段（TCP Segment）**，如下图所示：

![TCP分段.PNG](https://i.loli.net/2021/08/08/IS6iJurz5bw1Y2f.png)

当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是 **端⼝**。

浏览器（客户端）中的每个标签栏都是⼀个 **独⽴的进程**，操作系统会为这些进程分配临时的端⼝号。

#### 网络层

我们不希望传输层协议处理太多的事情，只需要服务好应⽤即可，让其作为应⽤间数据传输的媒介，帮助实现应⽤到应⽤的通信，⽽实际的传输功能就交给下⼀层，也就是 **⽹络层（Internet Layer）**。

网络层最常使用的是 **IP协议（Internet Protocol）**，IP 协议会将传输层的报⽂作为数据部分，再加上 IP 包头组装成 IP 报⽂，如果 IP 报⽂⼤⼩超过 **最大传输单元MTU**（以太⽹中⼀般为 1500 字节），就会再次进⾏ **分⽚**，得到⼀个即将发送到⽹络的 IP 报⽂。

![IP报文.PNG](https://i.loli.net/2021/08/08/lPdOjzaUb5VNvTW.png)

⽹络层负责 **将数据从⼀个设备传输到另⼀个设备**。因此，⽹络层需要有区分设备的编号。

⼀般⽤ **IP 地址** 给设备进⾏编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段，每段是 8 位。 IP 地址可以分成两种意义：

- 一个是 **网络号**，负责标识该 IP 地址属于哪个子网；
- 一个是 **主机号**，负责标识同一子网下的不同主机；

这需要配合 **子网掩码** 才能算出 IP 地址 的⽹络号和主机号。在寻址的过程中，先匹配到相同的⽹络号，再去找对应的主机。

除了寻址能⼒， IP 协议还有另⼀个重要的能⼒就是 **路由**。实际场景中，两台设备并不是⽤⼀条⽹线连接起来的，⽽是通过很多⽹关、路由器、交换机等众多⽹络设备连接起来的，那么就会形成很多条⽹络的路径。因此，当数据包到达⼀个⽹络节点，就需要通过算法决定下⼀步⾛哪条路径。

所以，**IP 协议的寻址作用是告诉我们去往下⼀个⽬的地该朝哪个⽅向⾛，路由则是根据「下⼀个⽬的地」选择路径**。寻址更像在导航，路由更像在操作⽅向盘。

#### 数据链路层

网络中由一个专⻔的层来标识⽹络中的设备，让数据在⼀个链路中传输，这就是 **数据链路层（Data Link Layer）**，它主要为⽹络层提供链路级别传输的服务。

每⼀台设备的⽹卡都会有⼀个 MAC 地址，⽤来唯⼀标识设备。路由器计算出了下⼀个⽬的地 IP 地址，再通过 **ARP 协议** 找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。

#### 物理层

当数据要从设备发送到⽹络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是 **物理层（Physical Layer）**，它主要是为数据链路层提供⼆进制传输的服务。

## 二、HTTP篇

### 2.1 HTTP基本概念

HTTP 是 **超⽂本传输协议**。

HTTP 是⼀个⽤在计算机世界⾥的协议。它使⽤计算机能够理解的语⾔确⽴了⼀种计算机之间交流通信的规范（**两个以上的参与者**），以及相关的各种控制和错误处理⽅式（**⾏为约定和规范**）。

HTTP 是⼀个在计算机世界⾥专⻔⽤来在 **两点之间传输数据** 的约定和规范。

HTTP 是⼀个 **在计算机世界⾥专⻔在「两点」之间「传输」⽂字、图⽚、⾳频、视频等「超⽂本」数据的「约定和规范」**。

#### HTTP常见状态码

![HTTP状态码.PNG](https://i.loli.net/2021/08/08/ZtTljcFDWEIfRsk.png)

### 2.2 HTTP特性

#### HTTP 1.1 优点

HTTP 最凸出的优点是「简单、灵活和易于扩展、应⽤⼴泛和跨平台」。

#### 缺点

HTTP 协议⾥有优缺点⼀体的双刃剑，分别是**「⽆状态、明⽂传输」**，同时还有⼀⼤缺点**「不安全」**。

##### 无状态——双刃剑

⽆状态的好处，因为服务器不会去记忆 HTTP 的状态，所以 **不需要额外的资源来记录状态信息**，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务。

⽆状态的坏处，既然服务器没有记忆能⼒，它在完成有关联性的操作时会⾮常麻烦。例如登录->添加购物⻋->下单->结算->⽀付，这系列操作都要知道⽤户的身份才⾏。但服务器不知道这些请求是有关联的，每次都要问⼀遍身份信息。

对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ **Cookie 技术**。

`Cookie` 通过 **在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态**。

##### 明文传输——双刃剑

明⽂意味着在传输过程中的信息，是可⽅便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接⾁眼查看，为调试⼯作带了极⼤的便利性。

但正是这样，HTTP 的所有信息都暴露在了光天化⽇下，相当于信息裸奔。在传输的漫⻓的过程中，信息的内容都毫⽆隐私可⾔，很容易就能被窃取，如果⾥⾯有你的账号密码信息，那你号没了。

##### 不安全

HTTP 比较严重的缺点就是不安全：

- 通信使用明文（不加密），内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。
- 不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。
- ⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。

HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过 **引⼊ SSL/TLS 层**，使得在安全上达到了极致。

#### HTTP/1.1 性能

HTTP 协议是基于 **TCP/IP**，并且使⽤了 **「请求 - 应答」** 的通信模式。

##### 1、长连接

早期 HTTP/1.0 性能上的⼀个很⼤的问题，那就是每发起⼀个请求，都要新建⼀次 TCP 连接（三次握⼿），⽽且是串⾏请求，做了⽆谓的 TCP 连接建⽴和断开，增加了通信开销。

为了解决上述 TCP 连接问题，HTTP/1.1 提出了 **⻓连接** 的通信⽅式，也叫持久连接。这种⽅式的好处在于减少了TCP 连接的᯿复建⽴和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态。

##### 2、管道网络传输

HTTP/1.1 采⽤了⻓连接的⽅式，这使得管道（pipeline）⽹络传输成为了可能。

即可在同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以 **减少整体的响应时间**。

##### 3、对头阻塞

「请求 - 应答」的模式加剧了 HTTP 的性能问题。

因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据，这也就是 **「队头阻塞」**。

### 2.3 HTTP 与 HTTPs

#### 两者区别

- HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 **SSL/TLS 安全协议**，使得报⽂能够加密传输；
- HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输；
- HTTP 的端⼝号是 **80**，HTTPS 的端⼝号是 **443**；
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

HTTP 由于是明⽂传输，所以安全上存在以下三个⻛险：

- **窃听⻛险**，⽐如通信链路上可以获取通信内容；
- **篡改⻛险**，⽐如强制植⼊垃圾⼴告，视觉污染；
- **冒充⻛险**，⽐如冒充淘宝⽹站。

HTTPS 在 HTTP 与 TCP 层之间加⼊了 **SSL/TLS 安全协议**，可以很好的解决上述⻛险：

- **信息加密**：交互信息⽆法被窃取；
- **校验机制**：⽆法篡改通信内容，篡改了就不能正常显示；
- **身份证书**：证明淘宝是真的淘宝⽹。

#### HTTPS 是如何解决上⾯的三个⻛险的

- **混合加密** 的⽅式实现信息的 **机密性**，解决了窃听的⻛险；
- **摘要算法** 的⽅式来实现 **完整性**，它能够为数据⽣成独⼀⽆⼆的「指纹」，指纹⽤于校验数据的完整性，解决了篡改的⻛险；
- 将服务器公钥放⼊到数字证书中，解决了冒充的⻛险。

##### 混合加密

HTTPS 采⽤的是 **对称加密** 和 **⾮对称加密** 结合的「混合加密」⽅式：

- 在通信建⽴前 **采⽤⾮对称加密的⽅式交换「会话秘钥」**，后续就不再使⽤⾮对称加密；
- 在通信过程中全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。

采⽤「混合加密」的⽅式的原因：

- **对称加密** 只使⽤⼀个密钥，**运算速度快**，密钥必须保密，⽆法做到安全的密钥交换；
- **⾮对称加密** 使⽤两个密钥：公钥和私钥，公钥可以任意分发⽽私钥保密，**解决了密钥交换问题** 但速度慢。

##### 摘要算法

客户端在发送明⽂之前会通过摘要算法算出明⽂的「指纹」，发送的时候把「指纹 + 明⽂」⼀同加密成密⽂后，发送给服务器，服务器解密后，⽤相同的摘要算法算出发送过来的明⽂，通过⽐较客户端携带的「指纹」和当前算出的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。

##### 数字证书

借助第三⽅权威机构 `CA （数字证书认证机构）`，将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。

#### HTTPS 是如何建⽴连接的？其间交互了什么？

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥；
- 双⽅协商⽣产「会话秘钥」；
- 双⽅采⽤「会话秘钥」进⾏加密通信。

SSL/TLS 协议建⽴的详细流程：

##### 1、Client Hello

⾸先，由客户端向服务器发起加密通信请求，也就是 ==Client Hello 请求==。

##### 2、Server Hello

服务器收到客户端请求后，向客户端发出响应，也就是 ==Sever Hello== 。

##### 3、客户端回应

客户端收到服务器的回应之后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使⽤它加密报⽂，向服务器发送信息；

##### 4、服务器最后响应

服务器收到客户端的第三个随机数后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP 协议，只不过⽤「会话秘钥」加密内容。

## 三、TCP篇

### 3.1 TCP基础

#### 1、TCP基本认识

##### TCP 头部格式

![TCP头.PNG](https://i.loli.net/2021/08/09/NIFQgTZwpyvJOsx.png)

**序列号SYN**：在建⽴连接时由计算机⽣成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送⼀次数据，就「累加」⼀次该「数据字节数」的⼤⼩。⽤来 **解决⽹络包乱序问题**。

**确认应答号ACK**：指下⼀次 **期望收到的数据的序列号**，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。⽤来 **解决不丢包的问题**。

**控制位**：

- `ACK`：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须设置为 1；
- `RST`：该位为 1 时，表示 TCP 连接中 **出现异常必须强制断开连接**；
- `SYN`：该位为 1 时，表示 **希望建⽴连接**，并在其「序列号」的字段进⾏序列号初始值的设定；
- `FIN`：该位为 1 时，表示今后不会再有数据发送，**希望断开连接**。

##### 为什么需要 TCP 协议

IP 层是 **不可靠** 的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。

如果需要 **保障⽹络数据包的可靠性**，那么就需要由上层（传输层）的 TCP 协议来负责。

因为 TCP 是⼀个⼯作在 **传输层的可靠数据传输的服务**，它能确保接收端接收的⽹络包是 **⽆损坏、⽆间隔、⾮冗余和按序的**。

##### 什么是 TCP

TCP 是 **⾯向连接的、可靠的、基于字节流** 的传输层通信协议。

- 面向连接：**一对一**才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息；
- 可靠的：⽆论的⽹络链路中出现了怎样的链路变化，TCP 都可以保证⼀个报⽂⼀定能够到达接收端；
- 字节流：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的报⽂会⾃动丢弃。

##### 什么是 TCP 连接

⽤于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 **Socket、序列号和窗⼝⼤⼩** 称为连接。

因此，建⽴⼀个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识：

- **Socket**：由 IP 地址和端口号组成；
- **序列号**：用来解决乱序问题；
- **窗口大小**：用来实现流量控制。

##### 唯一地确定一个 TCP 连接

TCP 四元组可以唯⼀的确定⼀个连接，四元组包括：**源地址、源端口、目的地址、目的端口**。

- 源地址和目的地址的字段（32位）在 **IP 头部** 中，作用是通过 IP 协议发送报文给对方主机；

- 源端口和目的端口的字段（16位）在 **TCP头部** 中，作用是告诉 TCP 协议应该把报文发送给哪个进程。

##### 有一个 IP 的服务器监听了一个端口，它的 TCP 最大连接数是多少

服务器通常固定在某个本地端口上监听，等待客户端的连接请求。

因此，客户端 IP 和 端口是可变的，其理论值计算公式如下：
$$
Maxmum_{TCP}=IP_{client}*Port_{client}
$$
对于 $IPv4$，客户端的 IP 数最多为 $2^{32}$，客户端的端口数最多为 $2^{16}$，即服务器的最大 TCP 连接数，约为 $2^{48}$。

当然，实际场景中，服务端的最大并发 TCP 连接数远不能达到理论上限。

- 首先主要是 **文件描述符限制**，Socket 都是文件，所有要通过 `ulimit` 配置文件描述符的数目；
- 其次是 `内存限制`，每个 TCP 连接都要占用一定的内存，而操作系统的内存是有限的。

##### UDP 和 TCP 的区别和各自应用场景

UDP 不提供复杂的控制机制，利⽤ IP 提供 **⾯向⽆连接的通信服务**。

UDP 头部如下：

![UDP头.PNG](https://i.loli.net/2021/08/08/AxQ4BeDORGzburE.png)

TCP 和 UDP 区别：

1. 连接：
   - TCP 是 **面向连接** 的传输层协议，传输数据前先要建立连接。
   - UDP 是 **面向无连接** 
2. 服务对象
   - TCP 是 **一对一的两点服务**
   - UDP 则支持 一对一、一对多、多对多的交互通信
3. 可靠性：
   - TCP 是**可靠交付数据** 的，数据可以无差错、不丢失、不重复、按需到达；
   - UDP 则是尽最大努力交付，不保证可靠交付数据
4. 拥塞控制、流量控制：
   - TCP **有拥塞控制和流量控制机制**，保证数据传输的安全性；
   - UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
5. 首部开销：
   - TCP 首部长度较长，会有一定的开销，首部在没有使用 `选项` 字段时是 ==20 字节==，如果使用了 `选项` 字段，则会更长；
   - UDP 首部只有 ==8 字节==，并且是固定不变的，开销较小。
6. 传输方式：
   - TCP 是 **流式传输**，没有边界，但保证顺序和可靠；
   - UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
7. 分片不同：
   - TCP 的数据⼤⼩如果 **⼤于 MSS **，则会 **在传输层进⾏分⽚**，⽬标主机收到后，也同样 **在传输层组装 TCP数据包**，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚；
   - UDP 的数据⼤⼩如果 **⼤于 MTU **，则会 **在 IP 层进⾏分⽚**，⽬标主机收到后，在 **IP 层组装完数据**，接着再传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要 **重传所有的数据包**，这样传输效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU。

##### 为什么 UDP 头部有包长度字段，而 TCP 头部则没有

TCP 计算负载数据长度公式：
$$
TCP_{data} = IP_{len}-IP_{header}-TCP_{header}
$$
UDP 也可以通过类似的方式计算。因此 UDP 头部中的包长度字段实际是 **冗余的**。

#### 2、TCP 连接建立

TCP 是⾯向连接的协议，所以使⽤ TCP 前必须先建⽴连接，⽽建⽴连接是通过 **三次握⼿** 来进⾏的。

<img src="https://i.loli.net/2021/08/09/JAxY2UbOaBkI1um.png" alt="三次握手.PNG" style="zoom: 80%;" />

- 初始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态；

![第一个SYN报文.PNG](https://i.loli.net/2021/08/09/9dFKszWNVcg3Gve.png)

- 客户端随机初始化序号（`client_isn`），将此序号置于 TCP 首部的 `序列号` 字段中，同时把 `SYN` 标志位置为 ==1==，表示 ==SYN报文==。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后哭护短处于 `SYN_SENT` 状态；

![第二个报文.PNG](https://i.loli.net/2021/08/09/MEf8py7uSQtAZ96.png)

- 服务端收到客户端的 ==SYN 报文== 后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入TCP 首部的 `序列号` 字段中，其次把 TCP 首部的 `确认应答号` 字段填入 `client_isn+1`，同时把 `SYN` 和 `ACK` 标志位置为 ==1==。最后把该报文发送给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。

![第三个报文.PNG](https://i.loli.net/2021/08/09/G7QIlENvFWTKCmo.png)

- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，把 `ACK` 标志位置为 ==1==，其次在 `确认应答号` 字段填入 `server_isn+1`，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 `ESTABLISHED` 状态。
- 服务器收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。

##### 为什么需要三次握手？

###### 原因一：避免历史连接

三次握手的首要原因是 **为了防止旧的重复连接初始化造成混乱**。

<img src="https://i.loli.net/2021/08/09/AVbZgdMfoWJI8nt.png" alt="三次握手避免历史连接.PNG" style="zoom: 67%;" />

举个例子，客户端连续发送多次 `SYN` 建立连接的报文，在 **网络拥堵** 情况下：

- 一个 「旧 SYN 报⽂」⽐「最新的 SYN 」 报⽂早到达了服务端；
- 那么此时服务端就会回⼀个 ==SYN + ACK 报⽂== 给客户端；
- 客户端收到后可以根据⾃身的上下⽂，**判断这是⼀个历史连接（序列号过期或超时）**，那么客户端就会发送==RST 报⽂== 给服务端，表示中⽌这⼀次连接

如果是两次握手连接，服务端收到一个失效的报文后，会误认为是一个新的连接请求，于是会发出一个确认报文，同意建立连接。但是客户端并没有发出建立连接的请求，因此不会去向服务端发送数据，服务端没有收到数据就会一直等待，这样 **服务端就会浪费掉很多资源**。

###### 原因二：同步双方初始序列号

TCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素，它的作⽤：

- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中，哪些是已经被对方收到的；

当客户端发送携带「初始序列号」的 ==SYN 报⽂== 的时候，需要服务端回⼀个 ==ACK 应答报⽂==，表示客户端的 SYN 报⽂已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样**⼀来⼀回，才能确保双⽅的初始序列号能被可靠的同步**。

<img src="https://i.loli.net/2021/08/09/2RvHeJcLd4BkWs3.png" alt="同步序列号.PNG"  />

四次握⼿其实也能够可靠的同步双⽅的初始化序号，但由于 **第⼆步和第三步可以优化成⼀步**，所以就成了 **三次握⼿**。

###### 原因三：避免资源浪费

如果客户端的 **SYN 阻塞**了，重复发送多次 SYN 报⽂，那么服务器在收到请求后就会建⽴多个冗余的⽆效链接，造成不必要的资源浪费。

<img src="https://i.loli.net/2021/08/09/4JZ8qMPIxs71bij.png" alt="资源浪费.PNG" style="zoom:67%;" />

不使用「两次握⼿」和「四次握⼿」的原因：

- 「两次握⼿」：⽆法防⽌历史连接的建⽴，会造成双⽅资源的浪费，也⽆法可靠的同步双⽅序列号；

- 「四次握⼿」：三次握⼿就已经理论上最少可靠连接建⽴，所以不需要使⽤更多的通信次数。

##### 为什么 TCP 层还需要 MSS？

![MTU和MSS.PNG](https://i.loli.net/2021/08/09/lvdcKrJesCEDagx.png)

- `MTU`：一个网络包的最大长度，以太网中一般为 ==1500 字节==；
- `MSS` ：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

当 IP 层有⼀个超过 `MTU` ⼤⼩的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进⾏分⽚，把数据分⽚成若⼲⽚，保证每⼀个分⽚都⼩于 `MTU`。把⼀份 IP 数据报进⾏分⽚以后，由⽬标主机的 IP 层来进⾏重新组装后，再交给上⼀层 TCP 传输层。

**当其中一个 IP 分片丢失，整个IP 报文的所有分片都需要重传**。

 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责处理超时和重传。

当接收⽅发现 TCP 报⽂（头部 + 数据）的某⼀⽚丢失后，则不会响应 ACK 给对⽅，那么发送⽅的 TCP 在超时后，就会 **重发「整个 TCP 报⽂（头部 + 数据）」**。

因此，由 IP 层进⾏分⽚传输，是⾮常没有效率的。

为了达到最佳的传输效能， TCP 协议在 **建⽴连接的时候通常要协商双⽅的 MSS 值**，当 TCP 层发现数据超过MSS 时，则就先会进⾏分⽚，当然由它形成的 IP 包的⻓度也就不会⼤于 MTU ，⾃然也就不⽤ IP 分⽚了。

经过 TCP 层分⽚后，如果⼀个 TCP 分⽚丢失后，**进⾏重发时也是以 MSS 为单位**，⽽不⽤重传所有的分⽚，⼤⼤增加了重传的效率。

##### SYN 攻击与防范

###### SYN 攻击

 TCP 连接建⽴是需要三次握⼿，假设攻击者短时间伪造不同 IP 地址的 SYN 报⽂，服务端每接收到⼀个 SYN 报⽂，就进⼊ SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报⽂，⽆法得到未知 IP 主机的 ACK 应答，久⽽久之就会 **占满服务端的 SYN 接收队列（未连接队列）**，使得服务器不能为正常⽤户服务。

###### 避免方式一

修改 Linux 内核参数，控制队列⼤⼩和当队列满时应做什么处理。

###### 避免方式二

先来看下 Linux 内核的 SYN （未完成连接建⽴）队列与 Accpet （已完成连接建⽴）队列是如何⼯作的：

<img src="https://i.loli.net/2021/08/09/BvN89Roq3aHrxZ7.png" alt="正常流程.PNG" style="zoom: 80%;" />

如果不断受到 `SYN 攻击`，就会导致 SYN 队列被占满。

==tcp_syncookies== 可以应对 `SYN 攻击`：

``` c
net.ipv4.tcp_syncookies = 1
```

<img src="https://i.loli.net/2021/08/09/16uDGpOQmkb8vcN.png" alt="syncookies.PNG" style="zoom:80%;" />

- 当「 SYN 队列」满之后，后续服务器收到 SYN 包，不进⼊「 SYN 队列」；
- 计算出⼀个 ==cookie 值==，再以 SYN + ACK 中的「序列号」返回客户端，

- 服务端接收到客户端的应答报⽂时，服务器会检查这个 ACK 包的合法性。如果合法，直接放⼊到「 Accept 队列」。
- 最后应⽤通过调⽤ ==accpet()== socket 接⼝，从「 Accept 队列」取出的连接。

#### 3、TCP 连接断开

TCP 断开连接是通过 **四次挥⼿** ⽅式。

双⽅都可以主动断开连接，断开连接后主机中的「资源」将被释放。

<img src="https://i.loli.net/2021/08/09/al4pDn2kuNYJAOC.png" alt="四次挥手.PNG" style="zoom:80%;" />

- 客户端打算关闭连接，会发送一个 TCP 首部 `FIN` 标志位被置为 1 的报文，即 ==FIN 报文==，之后客户端进入 `FIN_WAIT_1` 状态；
- 服务器端收到该报文后，会向客户端发送 ==ACK 应答报文==，接着服务器端进入 `CLOSED_WAIT` 状态；
- 客户端收到服务器端的 ==ACK 应答报文后==，进入 `FIN_WAIT_2` 状态；
- 等待服务器端处理完数据后，也向客户端发送 ==FIN 报文==，之后服务器进入 `LAST_ACK` 状态；
- 客户端收到服务器端的 ==FIN 报文== 后，回一个 ==ACK 应答报文==，之后进入 `TIME_WAIT` 状态；
- 服务器端收到了  ==ACK 应答报文==后，进入 `CLOSED` 状态，⾄此服务端已经完成连接的关闭；
- 客户端在经过 ==2MSL== 一段时间后，自动进入 `CLOSED` 状态，⾄此客户端也完成连接的关闭。

##### 为什么需要四次挥手？

- 关闭连接时，客户端向服务端发送 ==FIN 报文== 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务器收到客户端的 ==FIN 报⽂== 时，先回⼀个 ==ACK 应答报⽂==，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。

服务端通常 **需要等待完成数据的发送和处理**，所以服务端的 ACK 和 FIN ⼀般都会 **分开发送**，从⽽⽐三次握⼿导致多了⼀次。

##### 为什么 TIME_WAIT 等待的时间时 2MSL

`MSL` 是 **Maximum Segment Lifetime，报⽂最大生存时间**，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。

`MSL` 与 `TTL` 的区别： `MSL` 的单位是 **时间**，⽽ `TTL` 是 **经过路由跳数**。所以 MSL 应该要⼤于等于 TTL 消耗为 0 的时间，以确保报⽂已被⾃然消亡。

`TIME_WAIT` 等待 2 倍的 `MSL`，⽐较合理的解释是： 可以保证在两个传输方向上的尚未接收到或者迟到的报文段已经消失，否则如果服务器立即重启，可能会收到来自上一个进程迟到的数据，但是这种数据很可能是错误的，同时也是在理论上保证最后一个报文可靠到达，假设最后一个 `ACK` 丢失，那么服务器会再重发一个 `FIN`，这是虽然客户端的进程不在了，但是 TCP 连接还在，仍然可以重发 `LAST_ACK`。

==2MSL== 的时间是从客户端接收到 ==FIN 报文== 后发送 ==ACK 应答报文== 开始计时的。如果在 `TIME-WAIT` 时间内，因为客户端的 ==ACK 应答报文== 没有传输到服务端，客户端⼜接收到了服务端重发的 ==FIN 报文== 报⽂，那么 2MSL 时间将重新计时。

在 Linux 系统⾥ ==2MSL==  默认是 60 秒，那么⼀个 MSL 也就是 30 秒。

##### 为什么需要 TIME_WAIT 状态

主动发起关闭连接的一方，才会有 `TIME_WAIT` 状态。原因包括：

- 防⽌具有相同「四元组」的「旧」数据包被收到；
- 保证「被动关闭」的⼀⽅能被正确的关闭，即保证最后的 `ACK` 能让被动关闭⽅接收，从⽽帮助其正常关闭；

###### 防止旧连接的数据包

假设 `TIME_WAIT` 没有等待时间或时间过短，被延迟的数据包抵达了客户端，那么客户端是有可能正常接收这个过期的报⽂，这就会产⽣数据错乱等严重的问题。

经过 ==2MSL== 的时间，⾜以让两个⽅向上的数据包都被丢弃，使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。

###### 保证连接正确关闭

`TIME-WAIT` 作⽤是 **等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关闭**。

假设 `TIME_WAIT` 没有等待时间或时间过短，断开连接会造成什么问题呢？

![TIME_WAIT.PNG](https://i.loli.net/2021/08/09/oDjLAm2brFH7GS6.png)

- 如上图红⾊框框客户端四次挥⼿的最后⼀个 ==ACK 报⽂== 如果在⽹络中被丢失了，此时如果客户端 `TIME-WAIT ` 过短或没有，则就直接进⼊了` CLOSED` 状态了，那么服务端则会⼀直处在 `LASE_ACK` 状态。
- 当客户端发起建⽴新连接的 ==SYN 请求报⽂== 后，服务端会发送 ==RST 报⽂== 给客户端，新连接建⽴的过程就会被终⽌。

如果 TIME-WAIT 等待⾜够⻓的情况就会遇到两种情况：

- 服务端正常收到四次挥⼿的最后⼀个 ==ACK 报⽂==，则服务端正常关闭连接；
- 服务端没有收到四次挥⼿的最后⼀个 ==ACK 报⽂== 时，则会重发 ==FIN报文== 关闭连接，并等待新的 ==ACK 报⽂==。

##### TIME_WAIT 过多的危害

有处于 `TIME-WAIT` 状态的 TCP，则说明是由该⽅ **主动发起** 的断开请求。

 过多的 `TIME-WAIT` 状态主要的危害有两种：

- 内存资源占用；
- 对端口资源的占用，一个 TCP 连接消耗一个本地端口；

如果发起连接⼀⽅的 `TIME_WAIT` 状态过多，占满了所有端⼝资源，则会导致 **⽆法创建新连接**。

客户端受端口资源限制：

- 客户端 `TIME_WAIT` 过多，就会导致端⼝资源被占⽤，因为端⼝就 65536 个，被占满就会导致⽆法创建新的连接。

服务器端受系统资源限制：

- 由于⼀个四元组表示 TCP 连接，理论上服务端可以建⽴很多连接，服务端确实只监听⼀个端口，但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听。但是线程池处理不了那么多⼀直不断的连接了。所以当服务端出现⼤量 `TIME_WAIT` 时，系统资源被占满时，会导致处理不过来新的连接

##### 建立连接后，客户端挂掉

TCP 有⼀个 **保活机制**，用于处理这种情况：定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作⽤，**每隔⼀个时间间隔，发送⼀个探测报⽂**，该探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应⽤程序。

开启了 **TCP 保活机制** 后，存在以下⼏种情况：

- 对端程序正常⼯作。当 TCP 保活的探测报⽂发送给对端, 对端会正常响应，这样 TCP 保活时间会被 **重置**，等待下⼀个 TCP 保活时间的到来。
- 对端程序崩溃并重启。当 TCP 保活的探测报⽂发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，会产⽣⼀个 ==RST 报⽂==，这样很快就会发现 TCP 连接已经被重置。
- 对端程序崩溃，或对端由于其他原因导致报⽂不可达。当 TCP 保活的探测报⽂发送给对端后，⽯沉⼤海，没有响应，连续⼏次，达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡。

#### 4、Socket 编程

##### TCP Socket 编程

![TCP_socket.PNG](https://i.loli.net/2021/08/05/1Gj7JDBFmz3o5YO.png)

- 服务端和客户端初始化 `socket`，得到文件描述符；
- 服务端调用 `bind`，将绑定在 IP 地址和端口；
- 服务端调用 `listen`，进行监听；
- 服务端调用 `accept`，等待客户端连接；
- 客户端调用 `connect`，向服务器端的地址和端口发起连接请求；
- 服务端 `accept` 返回用于传输的 `socket` 的文件描述符；
- 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；
- 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据时，就会读取到 ==EOF==，待处理完数据后，服务端调用 `close`，表示连接关闭。

服务端调⽤ `accept` 时，连接成功了会返回⼀个 **已完成连接的** `socket`，后续⽤来传输数据。

即监听的 `socket` 和真正用来传送数据的 `socket`，是两个 `socket`，一个叫作 **监听** `socket`，一个叫作 **已完成连接的** `socket`。

##### listen 时参数 backlog 的意义

Linux 内核会维护两个队列：

- 未完成连接队列（SYN 队列）：接收到⼀个 SYN 建⽴连接请求，处于 `SYN_RCVD` 状态；

- 已完成连接队列（Accept 队列）：已完成 TCP 三次握⼿过程，处于 `ESTABLISHED` 状态.

<img src="https://i.loli.net/2021/08/09/8Y2bp5gHMF67uDv.png" alt="内核队列.PNG" style="zoom:80%;" />

``` c
int listen(int socketfd, int backlog)
```

- `socketfd` 为文件描述符
- `backlog` 参数在历史版本中有一定的变化

现在通常认为 `backlog` 是 `accept` 队列。

##### accept 发生在三次握手的哪一步

<img src="C:\Users\10295\AppData\Roaming\Typora\typora-user-images\image-20210809143213836.png" alt="image-20210809143213836" style="zoom:80%;" />

- 客户端的协议栈向服务器端发送了 ==SYN 包==，并告诉服务器端当前发送序列号 `client_isn`，客户端进⼊`SYN_SENT` 状态；
- 服务器端的协议栈收到这个包之后，进⾏ ==ACK 应答==，应答的值为 `client_isn+1`，表示对 SYN 包 `client_isn `的确认，同时服务器也发送⼀个 ==SYN 包==，告诉客户端当前我的发送序列号为 `server_isn`，服务器端进⼊ `SYN_RCVD` 状态;
- 客户端协议栈收到 ACK 之后，使得应⽤程序从 `connect` 调⽤返回，表示客户端到服务器端的单向连接建⽴成功，客户端的状态为 `ESTABLISHED`，同时客户端协议栈也会对服务器端的 SYN 包进⾏应答，应答数据为`server_isn+1`；

- 应答包到达服务器端后，服务器端协议栈使得 `accept` 阻塞调⽤返回，这个时候服务器端到客户端的单向连接也建⽴成功，服务器端也进⼊ `ESTABLISHED` 状态。

由上图可知，客户端 `connect` 成功返回是在 **第⼆次握⼿**，服务端 `accept` 成功返回是在 **三次握⼿成功** 之后。

##### 客户端调用 close 

<img src="https://i.loli.net/2021/08/09/CEUMOJcv9ixbedB.png" alt="socket编程四次挥手.PNG" style="zoom:80%;" />

- 客户端调⽤ `close`，表明客户端没有数据需要发送了，则此时会向服务端发送 ==FIN 报⽂==，进⼊ `FIN_WAIT_1`状态；

- 服务端接收到了 ==FIN 报⽂==，TCP 协议栈会为 FIN 包插⼊⼀个⽂件结束符 EOF 到接收缓冲区中，应⽤程序可以通过 read 调⽤来感知这个 FIN 包。这个 **EOF 会被放在已排队等候的其他已接收的数据之后**，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再⽆额外数据到达。此时，服务端进⼊ `CLOSE_WAIT `状态；

- 当处理完数据后，⾃然就会读到 EOF ，于是也调⽤ `close` 关闭它的套接字，这会使得客户端会发出⼀个 ==FIN 报文==，之后处于 `LAST_ACK` 状态；
- 客户端接收到服务端的 FIN 包，并发送 ==ACK 确认包== 给服务端，此时客户端将进⼊ `TIME_WAIT` 状态；
- 服务端收到 ==ACK 确认包== 后，就进⼊了最后的 `CLOSE` 状态；
- 客户端经过 ==2MSL== 时间之后，也进⼊ `CLOSE` 状态。

### 3.2 TCP 重传、滑动窗口、流量控制、拥塞控制

#### 重传机制

TCP 实现可靠传输的⽅式之⼀，是通过 **序列号与确认应答**。

在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回⼀个确认应答消息，表示已收到消息。

<img src="https://i.loli.net/2021/08/09/pfyXunks2w1DLK3.png" alt="序列号与确认应答.PNG" style="zoom:80%;" />

TCP 针对数据包丢失的情况，会⽤ **重传机制** 解决，常见的重传机制包括：

- 超时重传
- 快速重传
- SACK
- D-SACK

##### 超时重传

重传机制的其中⼀个⽅式，就是在发送数据时，设定⼀个定时器，当超过指定的时间后，没有收到对⽅的 ACK 确认应答报⽂，就会重发该数据，也就是我们常说的超时重传。

TCP 会在以下两种情况发生超时重传：

- 数据包丢失
- 确认应答丢失

![超时重传.PNG](https://i.loli.net/2021/08/09/fJtTH2A9NDu1bSz.png)

###### RTT 与 RTO

**RTT（往返时延）**：从发送端发送数据开始，到发送端收到来自接收端的确认总共经历的时间

**RTO（超时重传时间）**

![RTO与RTT.PNG](https://i.loli.net/2021/08/09/ehrSpQAqmGLkd2K.png)

两种超时时间不同的情况：

- 当超时时间 **RTO 较大** 时，丢包后过很久才重发，没有没有效率，性能差；
- 当超时时间 **RTO 较小** 时，会导致可能并没有丢就᯿发，于是重发的就快，会增加⽹络拥塞，导致更多的超时，更多的超时导致更多的重发。

**超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值**。

如果超时重发的数据，再次超时的时候，⼜需要重传的时候，TCP 的策略是 **超时间隔加倍**。

每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送。

##### 快速重传

快速重传机制不以 时间为驱动，而是 **以数据驱动重传**。

![快速重传.PNG](https://i.loli.net/2021/08/09/DaZoBPWzqIxkpVT.png)

快速重传的⼯作⽅式是当 **收到三个相同的 ACK 报⽂时，会在定时器过期之前，重传丢失的报⽂段**。

##### SACK 方法

SACK （ Selective Acknowledgment 选择性确认）：需要在 TCP 头部「选项」字段⾥加⼀个 ==SACK== 的东⻄，它可以 **将缓存的地图发送给发送⽅**，这样发送⽅就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以 **只重传丢失的数据**。

![SACK.PNG](https://i.loli.net/2021/08/09/k6xZQC89uNfXthn.png)

在 Linux 下，可以通过 `net.ipv4.tcp_sack` 参数打开这个功能。

#### 滑动窗口

为每个数据包确认应答的缺点：包的往返时间越长，网络的吞吐量会越低，即通信效率越低。

为解决这个问题，TCP 引⼊了 **窗⼝** 这个概念。窗口大小是指 **⽆需等待确认应答，⽽可以继续发送数据的最⼤值**。

窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

![滑动窗口累计确认.PNG](https://i.loli.net/2021/08/09/2efXFlZ8CUvkAEq.png)

图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫 **累计确认** 或者 **累计应答**。

##### 窗口大小由哪一方决定

TCP 头⾥有⼀个字段叫 ==Window== ，也就是窗⼝⼤⼩。

这个字段是 **接收端** 告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。

所以，通常窗⼝的⼤⼩是 **由接收⽅的窗⼝⼤⼩** 来决定的。

##### 发送方的滑动窗口

![发送方滑动窗口1.PNG](https://i.loli.net/2021/08/09/J7fXbQa1rPTkUSR.png)

- #1 是已发送并收到 ACK 确认的数据：1~31 字节
- #2 是已发送但未收到 ACK 确认的数据：32~45 字节
- #3 是未发送但总⼤⼩在接收⽅处理范围内（接收⽅还有空间）：46~51字节
- #4 是未发送但总⼤⼩超过接收⽅处理范围（接收⽅没有空间）：52字节以后

在下图，当发送⽅把数据「全部」都⼀下发送出去后，可⽤窗⼝的⼤⼩就为 0 了，表明可⽤窗⼝耗尽，在没收到
ACK 确认之前是⽆法继续发送数据了。

![发送滑动窗口2.PNG](https://i.loli.net/2021/08/09/cQ6hUHxTEp4CYz1.png)

在下图，当收到之前发送的数据 32~36 字节的 ACK 确认应答后，如果发送窗⼝的⼤⼩没有变化，则 **滑动窗⼝往右边移动 5 个字节**，因为有 5 个字节的数据被应答确认，接下来 52~56 字节⼜变成了可⽤窗⼝，那么后续也就可以发送 `52~56` 这 5 个字节的数据了。

![发送方滑动窗口3.PNG](https://i.loli.net/2021/08/09/osgjCZKSIWEXYNM.png)

##### 接收方滑动窗口

接收窗口相对简单⼀些，根据处理的情况划分成三个部分：

- #1 + #2 是已成功接收并确认的数据（等待应⽤进程读取）；
- #3 是未收到数据但可以接收的数据；
- #4 未收到数据并不可以接收的数据；

![接收方滑动窗口.PNG](https://i.loli.net/2021/08/09/ZVO5DJEWIsUq9Ru.png)

接收窗口和发送窗口大小并不完全相等，因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，这样的话接收窗⼝可以很快的就空缺出来。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Window 字段来告诉发送⽅。那么这个传输过程是存在时延的，所以接收窗⼝和发送窗⼝是约等于的关系。

#### 流量控制

TCP 提供⼀种可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送数据量的机制，即 **流量控制**。

#### 拥塞控制

拥塞控制的⽬的就是 **避免「发送⽅」的数据填满整个⽹络**。

##### 拥塞窗口

拥塞窗口 `cwnd` 是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。

我们在前⾯提到过发送窗口 `swnd` 和接收窗口 `rwnd` 是约等于的关系，那么由于加⼊了拥塞窗口的概念后，此
时发送窗口的值是 $swnd = min(cwnd, rwnd)$，也就是拥塞窗口和接收窗口中的最⼩值。

拥塞窗口 `cwnd` 变化的规则：

- 只要⽹络中没有出现拥塞， `cwnd` 就会增⼤；

- ⽹络中出现了拥塞， `cwnd` 就减少；

只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是 **发⽣了超时重传**，就会认为⽹络出现了拥塞。

##### 拥塞控制算法

###### 慢启动

当发送⽅ **每收到⼀个 ACK，拥塞窗口 `cwnd` 的⼤⼩就会加 1**。举个例子：

- 连接建⽴完成后，⼀开始初始化 `cwnd = 1`，表示可以传⼀个 ==MSS== ⼤⼩的数据；

- 当收到⼀个 ACK 确认应答后，`cwnd` 增加 1，于是⼀次能够发送 2 个；
- 当收到 2 个的 ACK 确认应答后， `cwnd` 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个；

- 当这 4 个的 ACK 确认到来的时候，每个确认 `cwnd` 增加 1， 4 个确认 `cwnd` 增加 4，于是就可以⽐之前多发 4 个，所以这⼀次能够发送 8 个。

![慢启动.PNG](https://i.loli.net/2021/08/09/zPlNIQiMU5dD91Z.png)

有⼀个叫慢启动⻔限 `ssthresh` 状态变量：

- 当 $cwnd < ssthresh$ 时，使用 **慢启动算法**；
- 当 $cwnd \ge ssthresh$ 时，使用 **拥塞避免算法**。

###### 拥塞避免算法

进⼊拥塞避免算法后，它的规则是：**每收到⼀个 ACK 时，`cwnd` 增加 $\frac{1}{cwnd}$**。

接上前⾯的慢启动的例⼦，现假定 `ssthresh` 为 8 ：

- 当 8 个 ==ACK 确认应答== 到来时，每个确认增加 1/8，8 个 ACK 确认 `cwnd` ⼀共增加 1，于是这⼀次能够发送 9个 `MSS` ⼤⼩的数据，变成了线性增⻓。

![拥塞避免算法.PNG](https://i.loli.net/2021/08/09/9Kd1tw6iourD5fM.png)

拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶段，但是增⻓速度缓慢了⼀些。

⼀直增⻓后，网络就会慢慢进⼊拥塞的状况，于是就会出现丢包现象，这时就需要对丢失的数据包进⾏重传。

###### 拥塞发生算法

当⽹络出现拥塞，也就是会发⽣数据包重传，重传机制主要有两种：

- 超时重传
- 快速重传

当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。

这个时候，`ssthresh` 和 `cwnd` 的值会发⽣变化：

- `ssthresh` 设为 `cwnd/2`；
- `cwnd` 重置为 1.

![拥塞发生算法.PNG](https://i.loli.net/2021/08/09/JKfZ9WtMu3YCeyj.png)

接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是⼀旦「超时重传」，⻢上回到解放前。但是这种⽅式太激进了，反应也很强烈，会造成⽹络卡顿。

还有更好的⽅式，前⾯我们讲过 **「快速重传算法」**。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的ACK，于是发送端就会快速地重传，不必等待超时再重传。

TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 `ssthresh` 和 `cwnd` 变化如下：

- $cwnd = cwmd/2$；
- $ssthresh = cwnd$；
- 进入 **快速恢复算法**。

快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明⽹络也不那么糟糕，所以没有必要像 ==RTO== 超时那么强烈。

![快速恢复.PNG](https://i.loli.net/2021/08/09/3zceUntIlZsLayW.png)

快速回复算法如下：

- 拥塞窗口 $cwnd=ssthresh+3$;
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 `cwnd` 增加 1；
- 如果收到新数据的 ACK 后，把 `cwnd` 设置为第⼀步中的 `ssthresh` 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进⼊拥塞避免状态；

## 四、IP 篇

### 4.1、IP 基础知识

⽹络层的主要作⽤是：**实现主机与主机之间的通信，也叫点对点（end to end）通信**。

#### 网络层与数据链路层的关系

MAC 的作⽤则是实现「直连」的两个设备之间通信，⽽ IP 则负责在「没有直连」的两个⽹络之间进⾏通信传输。

![网络层与数据链路层.PNG](https://i.loli.net/2021/08/10/XlB8sPjG6EUFfkH.png)

源 IP 地址和⽬标 IP 地址在传输过程中是不会变化的，只有源 MAC 地址和⽬标 MAC ⼀直在变化。

### 4.2 IP 地址

#### IP 地址分类

<img src="https://i.loli.net/2021/08/10/6ykwqSIZC5lXGQe.png" alt="IP地址分类.PNG" style="zoom:80%;" />

黄色部分表示分类，用以区分 IP 地址类别。

##### A、B、C类地址

对于 A、B、C 类地址主要分为两个部分，分别是 **⽹络号** 和 **主机号**。

![三类地址.PNG](https://i.loli.net/2021/08/10/CPbYWzosAmqKIeF.png)

为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。

- 主机号全为 1 指定某个网络下的所有主机，用于广播
- 主机号全为 0 指定某个网络

##### 广播

⼴播地址可以分为本地⼴播和直接⼴播两种。

- **在本⽹络内⼴播的叫做本地⼴播**。例如⽹络地址为 `192.168.0.0/24` 的情况下，⼴播地址是 `192.168.0.255` 。因为这个⼴播地址的 IP 包会被路由器屏蔽，所以不会到达 `192.168.0.0/24` 以外的其他链路上。

- **在不同⽹络之间的⼴播叫做直接⼴播**。例如⽹络地址为 `192.168.0.0/24` 的主机向 `192.168.1.255/24` 的⽬标地址发送 IP 包。收到这个包的路由器，将数据转发给 `192.168.1.0/24`，从⽽使得所有`192.168.1.1~192.168.1.254` 的主机都能收到这个包（由于直接⼴播有⼀定的安全问题，多数情况下会在路由器上设置为不转发。） 。

![广播.PNG](https://i.loli.net/2021/08/10/oRipJgaltAfcqHL.png)

##### D、E类地址

D 类和 E 类地址是没有主机号的，所以不可⽤于主机 IP，D 类常被⽤于 **多播**，E 类是预留的分类，暂时未使⽤。

##### 多播地址

多播⽤于 **将包发送给特定组内的所有主机**。

由于 **⼴播⽆法穿透路由**，若想给其他⽹段发送同样的包，就可以使⽤可以穿透路由的多播。

![多播.PNG](https://i.loli.net/2021/08/10/L5dzWsPna8GS9Yk.png)

##### IP 地址分类的优缺点

优点：简单明了、选路简单

缺点：

1. **同⼀⽹络下没有地址层次**，⽐如⼀个公司⾥⽤了 B 类地址，但是可能需要根据⽣产环境、测试环境、开发环境来划分地址层次，⽽这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。

2. 不能很好的与现实网络匹配：
   - C 类地址能包含的最⼤主机数量太少了，只有 254 个；
   - B 类地址能包含的最⼤主机数量⼜太多了

#### 无分类地址 CIDR

这种⽅式不再有分类地址的概念，32 ⽐特的 IP 地址被划分为两部分，前⾯是 **⽹络号**，后⾯是 **主机号**。

表示形式 `a.b.c.d/x`，其中 `/x` 表示前 x 位属于 **网络号**，x 的范围是 `0 ~ 32`，这使得 IP 地址更加具有灵活性。

![CIDR.PNG](https://i.loli.net/2021/08/10/UXu6DL7OvAyVWaF.png)

还有另⼀种划分⽹络号与主机号形式，叫作 **⼦⽹掩码**，掩码的意思就是掩盖掉主机号，剩余的就是⽹络号。

**将⼦⽹掩码和 IP 地址按位 &，就可得到⽹络号**。

<img src="https://i.loli.net/2021/08/10/5p4Z79bYSwQF3Bj.png" alt="子网掩码.PNG" style="zoom:80%;" />

##### 为什么要分离网络号和主机号

因为两台计算机要通讯，⾸先要判断是否处于同⼀个⼴播域内，即⽹络地址是否相同。如果⽹络地址相同，表明接收⽅在本⽹络上，那么可以把数据包直接发送到⽬标主机。

##### 子网划分

可以通过⼦⽹掩码划分出⽹络号和主机号，那实际上⼦⽹掩码还有⼀个作⽤，那就是 **划分⼦⽹**。

子网划分实际上是将主机地址分为两个部分：**子网⽹络地址** 和 **子网主机地址**。

假设对 C 类⽹络地址 `192.168.1.0`，使⽤⼦⽹掩码 `255.255.255.192` 对其进⾏⼦⽹划分。

C 类地址中前 24 位是⽹络号，最后 8 位是主机号，根据⼦⽹掩码可知从 8 位主机号中借⽤ 2 位作为⼦⽹号。

![子网划分.PNG](https://i.loli.net/2021/08/10/lXCkAcruT6VvZeg.png)

由于⼦⽹⽹络地址被划分成 2 位，那么⼦⽹地址就有 4 个，分别是 00、01、10、11，具体划分如下图：

<img src="https://i.loli.net/2021/08/10/k7fYpsQhSjU51nZ.png" alt="子网.PNG" style="zoom: 67%;" />

#### 公有 IP 地址与私有 IP 地址

![公有IP与私有IP.PNG](https://i.loli.net/2021/08/10/s2OaUZqubIimt86.png)

#### IP 地址与路由控制

IP地址的⽹络地址这⼀部分是⽤于进⾏ **路由控制**。

![路由控制.PNG](https://i.loli.net/2021/08/10/17ZQoGvg6CpIjim.png)

- 主机 A 要发送⼀个 IP 包，其源地址是 `10.1.1.30` 和⽬标地址是 `10.1.2.10`，由于没有在主机 A 的路由表找到与⽬标地址 `10.1.2.10` 的⽹络地址，于是包被转发到 **默认路由（路由器 1 ）**

- 路由器 1 收到 IP 包后，也在路由器 1 的路由表匹配与⽬标地址相同的⽹络地址记录，发现匹配到了，于是就把 IP 数据包转发到了 `10.1.0.2` 这台路由器 2

- 路由器 2 收到后，同样对⽐⾃身的路由表，发现匹配到了，于是把 IP 包从路由器 2 的 `10.1.2.1` 这个接⼝出去，最终经过交换机把 IP 数据包转发到了⽬标主机

**环回地址** 是在同⼀台计算机上的程序之间进⾏⽹络通信时所使⽤的⼀个默认地址。

计算机使⽤⼀个特殊的 IP 地址 `127.0.0.1` 作为环回地址。与该地址具有相同意义的是⼀个叫做 `localhost` 的主机名。使⽤这个 IP 或主机名时，数据包不会流向⽹络。

#### IP 分片与重组

最常⻅数据链路是以太⽹，它的 MTU 是 1500 字节。

当 IP 数据包⼤⼩⼤于 MTU 时， IP 数据包就会被 **分片**。

经过分⽚之后的 IP 数据报在被重组的时候，只能由 **⽬标主机** 进⾏，路由器是不会进⾏重组的。

假设发送⽅发送⼀个 4000 字节的⼤数据报，若要传输在以太⽹链路，则需要把数据报分⽚成 3 个⼩数据报进⾏传输，再交由接收⽅重组成⼤数据报。

在分⽚传输中，⼀旦某个分⽚丢失，则会造成整个 IP 数据报作废，所以 TCP 引⼊了 `MSS` 也就是在 TCP 层进⾏分⽚不由 IP 层分⽚，那么对于 UDP 我们尽量不要发送⼀个⼤于 MTU 的数据报⽂。

#### IPv6 基本认识

 IPv6 的地址是 ==128 位==，

### 4.3、IP 协议相关技术

 #### DNS 域名解析

DNS 中的域名都是⽤句点来分隔的，⽐如 `www.server.com`，这⾥的句点代表了不同层次之间的界限。

在域名中，越靠右的位置表示其层级越⾼。

##### 域名解析过程

浏览器⾸先看⼀下⾃⼰的缓存⾥有没有，如果没有就向操作系统的缓存要，还没有就检查本机 **域名解析⽂件**`hosts` ，如果还是没有，就会 DNS 服务器进⾏查询，查询的过程如下：

1. 客户端⾸先会发出⼀个 DNS 请求，问 `www.server.com` 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）;
2. 本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 `www.server.com`，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器。根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。
3. 根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“`www.server.com` 这个域名归 `.com` 区域管理”，我给你 `.com` 顶级域名服务器地址给你，你去问问它吧。”

4. 本地 DNS 收到顶级域名服务器的地址后，发起请求;
5. 顶级域名服务器说：“我给你负责 `www.server.com` 区域的权威 DNS 服务器的地址，你去问它”；
6. 本地 DNS 于是转向问权威 DNS 服务器：“⽼三，`www.server.com` 对应的 IP 是啥呀？” `server.com` 的权威DNS 服务器，它是域名解析结果的原出处；
7. 权威 DNS 服务器查询后将对应的 IP 地址 `x.x.x.x` 告诉本地 DNS；
8. 本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接。

![DNS域名解析.PNG](https://i.loli.net/2021/08/10/X5VYfHaFgIcTkLC.png)

#### ARP 与 RARP 协议

##### ARP

在传输⼀个 IP 数据报的时候，确定了源 IP 地址和⽬标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下⼀跳。然⽽，⽹络层的下⼀层是数据链路层，所以我们还要知道「下⼀跳」的 **MAC 地址**。

由于主机的路由表中可以找到下⼀跳的 IP 地址，所以可以通过 ARP 协议，求得下⼀跳的 MAC 地址。

ARP 是借助 **ARP 请求** 与 **ARP 响应** 两种类型的包确定 MAC 地址的。

<img src="https://i.loli.net/2021/08/10/4uo95AxpL832Rci.png" alt="ARP协议.PNG" style="zoom:80%;" />

- 主机通过 **广播发送 ARP 请求**， 这个包中包含了想要知道的 MAC 地址的主机 IP 地址；
- 当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP地址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ **ARP 响应包** 返回给主机。

操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。

##### RARP

ARP 协议是已知 IP 地址求 MAC 地址，那 **RARP 协议** 正好相反，它是已知 MAC 地址求 IP 地址。

通常这需要架设⼀台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接⼊到⽹络，接着：

- 该设备会发送⼀条「我的 MAC 地址是 `xxxx`，请告诉我，我的 IP 地址应该是什么」的请求信息；

- RARP 服务器接到这个消息后返回「MAC地址为 `xxxx` 的设备，IP 地址为 `xxxx`」的信息给这个设备。

#### DHCP 动态获取 IP 地址

<img src="https://i.loli.net/2021/08/10/da19w7sYycpQ4Wx.png" alt="DHCP.PNG" style="zoom:80%;" />

DHCP 客户端进程监听的是 68 号端口，DHCP 服务端进程监听的是 67 号端口。

DHCP 工作流程包括 4 个步骤：

- 客户端⾸先发起 **DHCP 发现报⽂（DHCP DISCOVER）** 的 IP 数据报，由于客户端没有 IP 地址，也不知道DHCP 服务器的地址，所以使⽤的是 **UDP ⼴播通信**，其使⽤的⼴播⽬的地址是 `255.255.255.255`（端口
  67） 并且使⽤ 0.0.0.0（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后
  将帧⼴播到所有的⽹络中设备。

- DHCP 服务器收到 DHCP 发现报⽂时，⽤ DHCP 提供报⽂（DHCP OFFER） 向客户端做出响应。该报⽂仍然使⽤ IP ⼴播地址 `255.255.255.255`，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、DNS 服务器以及 IP 地址租⽤期。

- 客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送 **DHCP 请求报⽂（DHCP REQUEST）**进⾏响应，回显配置的参数。

- 最后，服务端⽤ **DHCP ACK 报⽂** 对 DHCP 请求报⽂进⾏响应，应答所要求的参数。

⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租⽤期内使⽤ DHCP 服务器分配的 IP 地址。

可以发现，DHCP 交互中，全程都是使⽤ **UDP ⼴播通信**。

#### NAT 网络地址转换

![NAT.PNG](https://i.loli.net/2021/08/10/1RHg4fNYQ2n8z53.png)

#### ICMP 协议

**ICMP** 全称是 Internet Control Message Protocol，也就是互联⽹控制报⽂协议。

ICMP 主要的功能包括：**确认 IP 包是否成功送达⽬标地址、报告发送过程中 IP 包被废弃的原因和改善⽹络设置等**。

在 IP 通信中如果某个 IP 包因为某种原因未能达到⽬标地址，那么这个具体的原因将由 ICMP 负责通知。

